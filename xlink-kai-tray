#!/usr/bin/env python3
"""XLink Kai tray launcher."""
import os
import sys
import signal
import subprocess
import shutil
import configparser
from pathlib import Path

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib

ENGINE_SEARCH_PATHS = [
    Path("/usr/bin/kaiengine"),
    Path("/opt/kaiEngine-standalone/kaiengine"),
    Path.home() / ".local/bin/kaiengine",
    Path.home() / "kaiEngine-standalone/kaiengine",
]

WEB_UI = "http://localhost:34522"
CONFIG_FILE = Path.home() / ".config/xlink-kai/settings.conf"
DESKTOP_FILE = Path.home() / ".local/share/applications/xlink-kai.desktop"
AUTOSTART_FILE = Path.home() / ".config/autostart/xlink-kai.desktop"
ICON_PATH = Path.home() / ".local/share/icons/xlink-kai.png"

def find_engine():
    for p in ENGINE_SEARCH_PATHS:
        if p.is_file() and os.access(p, os.X_OK):
            return str(p)
    return None

def find_config(engine_path):
    if not engine_path:
        return None
    engine_dir = Path(engine_path).parent
    for name in ["kaiengine.conf", "kaid.conf"]:
        conf = engine_dir / name
        if conf.exists():
            return str(conf)
    xlink_conf = Path.home() / ".xlink/kaiengine.conf"
    if xlink_conf.exists():
        return str(xlink_conf)
    return None

def load_config():
    cfg = {"engine": None, "config": None}
    if CONFIG_FILE.exists():
        parser = configparser.ConfigParser()
        parser.read(CONFIG_FILE)
        if parser.has_section("xlink-kai"):
            engine = parser.get("xlink-kai", "engine_path", fallback="")
            config = parser.get("xlink-kai", "config_path", fallback="")
            cfg["engine"] = engine or None
            cfg["config"] = config or None
    if not cfg["engine"]:
        cfg["engine"] = find_engine()
    if cfg["engine"] and not cfg["config"]:
        cfg["config"] = find_config(cfg["engine"])
    return cfg

def save_config(engine, config):
    CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)
    parser = configparser.ConfigParser()
    parser["xlink-kai"] = {"engine_path": engine or "", "config_path": config or ""}
    with open(CONFIG_FILE, "w") as f:
        parser.write(f)

def is_autostart_enabled():
    return AUTOSTART_FILE.exists()

def set_autostart(enabled):
    if enabled:
        if DESKTOP_FILE.exists():
            AUTOSTART_FILE.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(DESKTOP_FILE, AUTOSTART_FILE)
    else:
        AUTOSTART_FILE.unlink(missing_ok=True)

def choose_engine_path(current_path):
    dialog = Gtk.FileChooserDialog(
        title="Select kaiengine",
        action=Gtk.FileChooserAction.OPEN,
    )
    dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
    if current_path and Path(current_path).parent.exists():
        dialog.set_current_folder(str(Path(current_path).parent))
    response = dialog.run()
    path = dialog.get_filename() if response == Gtk.ResponseType.OK else None
    dialog.destroy()
    return path

def show_error(title, message):
    dialog = Gtk.MessageDialog(
        message_type=Gtk.MessageType.ERROR,
        buttons=Gtk.ButtonsType.OK,
        text=title,
        secondary_text=message
    )
    dialog.run()
    dialog.destroy()

def get_indicator():
    for name in ('AyatanaAppIndicator3', 'AppIndicator3'):
        try:
            gi.require_version(name, '0.1')
            return __import__('gi.repository', fromlist=[name]).__dict__[name]
        except (ImportError, ValueError, KeyError):
            pass
    return None

def get_distro_packages():
    """Return distro-specific install command, or None."""
    ids = set()
    if Path("/etc/os-release").exists():
        for line in Path("/etc/os-release").read_text().splitlines():
            if line.startswith("ID="):
                ids.add(line.split("=", 1)[1].strip('"').lower())
            elif line.startswith("ID_LIKE="):
                ids.update(line.split("=", 1)[1].strip('"').lower().split())
    packages = [
        ({"fedora", "rhel", "centos", "nobara", "bazzite", "ultramarine"},
            "sudo dnf install python3-gobject libayatana-appindicator-gtk3"),
        ({"ubuntu", "debian", "pop", "linuxmint", "elementary", "zorin"},
            "sudo apt install python3-gi gir1.2-ayatanaappindicator3-0.1"),
        ({"arch", "manjaro", "endeavouros", "garuda", "cachyos"},
            "sudo pacman -S python-gobject libayatana-appindicator"),
        ({"opensuse", "opensuse-leap", "opensuse-tumbleweed", "suse"},
            "sudo zypper install python3-gobject typelib-1_0-AyatanaAppIndicator3-0_1"),
    ]
    for distro_ids, cmd in packages:
        if ids & distro_ids:
            return cmd
    return None

class XLinkKai:
    def __init__(self, engine_path, config_path):
        self.engine_path = engine_path
        self.config_path = config_path
        self.engine_proc = None

    def start_engine(self):
        if not self.engine_path:
            return "Engine path not set"
        engine = Path(self.engine_path)
        if not engine.is_file():
            return f"Not found: {self.engine_path}"
        if not os.access(engine, os.X_OK):
            return f"Not executable: {self.engine_path}"
        if self.engine_proc and self.engine_proc.poll() is None:
            return True
        try:
            args = [self.engine_path]
            if self.config_path and Path(self.config_path).exists():
                args.extend(["--configfile", self.config_path])
            self.engine_proc = subprocess.Popen(args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except Exception as e:
            return str(e)

    def stop_engine(self):
        if not self.engine_proc:
            return
        self.engine_proc.terminate()
        try:
            self.engine_proc.wait(timeout=3)
        except subprocess.TimeoutExpired:
            self.engine_proc.kill()
            self.engine_proc.wait(timeout=2)
        self.engine_proc = None

    def open_ui(self):
        subprocess.Popen(["xdg-open", WEB_UI], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def main():
    cfg = load_config()
    engine_path = cfg["engine"]
    config_path = cfg["config"]

    if len(sys.argv) > 1 and sys.argv[1] in ("-h", "--help"):
        print(f"Usage: {sys.argv[0]}")
        print(f"\nConfig: {CONFIG_FILE}")
        print(f"\nEngine search paths:")
        for p in ENGINE_SEARCH_PATHS:
            print(f"  {'✓' if p.exists() else '✗'} {p}")
        sys.exit(0)

    if not engine_path or not Path(engine_path).exists():
        if not CONFIG_FILE.exists():
            save_config(None, None)
        engine_path = None
        config_path = None

    AppIndicator = get_indicator()
    if not AppIndicator:
        is_gnome = "gnome" in os.environ.get("XDG_CURRENT_DESKTOP", "").lower()
        msg = "AppIndicator library not found.\n\n"
        if is_gnome:
            msg += "GNOME requires the AppIndicator extension:\n"
            msg += "  extensions.gnome.org/extension/615/appindicator-support/\n\n"
        distro_cmd = get_distro_packages()
        if distro_cmd:
            msg += f"Install:\n  {distro_cmd}"
        else:
            msg += "Install python3-gobject + libayatana-appindicator for your distro"
        show_error("XLink Kai Error", msg)
        sys.exit(1)

    xlink = XLinkKai(engine_path, config_path)

    menu = Gtk.Menu()
    item_open = Gtk.MenuItem(label="Open Web UI")
    item_open.connect("activate", lambda _: xlink.open_ui())
    item_open.set_sensitive(xlink.engine_path is not None)
    menu.append(item_open)
    menu.append(Gtk.SeparatorMenuItem())

    def on_change_engine(_):
        path = choose_engine_path(xlink.engine_path)
        if not path:
            return
        if not os.access(path, os.X_OK):
            show_error("XLink Kai Error", f"Selected file is not executable:\n{path}")
            return
        new_config = find_config(path)
        xlink.stop_engine()
        xlink.engine_path = path
        xlink.config_path = new_config
        save_config(path, new_config)
        result = xlink.start_engine()
        if result is not True:
            show_error("XLink Kai Error", f"Failed to start engine:\n{result}")
        else:
            item_open.set_sensitive(True)

    item_engine = Gtk.MenuItem(label="Set Engine Path…")
    item_engine.connect("activate", on_change_engine)
    menu.append(item_engine)

    item_autostart = Gtk.CheckMenuItem(label="Autostart")
    item_autostart.set_active(is_autostart_enabled())
    item_autostart.connect("toggled", lambda w: set_autostart(w.get_active()))
    menu.append(item_autostart)

    menu.append(Gtk.SeparatorMenuItem())

    def quit_app(_=None):
        xlink.stop_engine()
        Gtk.main_quit()

    item_quit = Gtk.MenuItem(label="Stop & Quit")
    item_quit.connect("activate", quit_app)
    menu.append(item_quit)
    menu.show_all()

    icon_path = str(ICON_PATH) if ICON_PATH.exists() else "network-workgroup"
    indicator = AppIndicator.Indicator.new("xlink-kai", icon_path, AppIndicator.IndicatorCategory.APPLICATION_STATUS)
    indicator.set_status(AppIndicator.IndicatorStatus.ACTIVE)
    indicator.set_menu(menu)

    if xlink.engine_path:
        result = xlink.start_engine()
        if result is not True:
            show_error("XLink Kai Error", f"Failed to start engine:\n{result}")

    signal.signal(signal.SIGTERM, lambda *_: GLib.idle_add(quit_app))
    signal.signal(signal.SIGINT, lambda *_: GLib.idle_add(quit_app))
    Gtk.main()

if __name__ == "__main__":
    main()
