#!/usr/bin/env python3
import os
import sys
import signal
import subprocess
import shutil
import configparser
from pathlib import Path

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk, GLib

ENGINE_SEARCH_PATHS = [
    Path("/usr/bin/kaiengine"),
    Path("/opt/kaiEngine-standalone/kaiengine"),
    Path.home() / ".local/bin/kaiengine",
    Path.home() / "kaiEngine-standalone/kaiengine",
]

WEB_UI = "http://localhost:34522"
CONFIG_FILE = Path.home() / ".config/xlink-kai/settings.conf"
DESKTOP_FILE = Path.home() / ".local/share/applications/xlink-kai.desktop"
AUTOSTART_FILE = Path.home() / ".config/autostart/xlink-kai.desktop"
ICON_PATH = Path.home() / ".local/share/icons/xlink-kai.png"
LOCK_FILE = Path(os.environ.get("XDG_RUNTIME_DIR", "/tmp")) / "xlink-kai-tray.pid"

def check_single_instance():
    if LOCK_FILE.exists():
        try:
            pid = int(LOCK_FILE.read_text().strip())
            os.kill(pid, 0)
            return False
        except (ValueError, ProcessLookupError, PermissionError):
            pass
    LOCK_FILE.write_text(str(os.getpid()))
    return True

def remove_lock():
    LOCK_FILE.unlink(missing_ok=True)

def find_engine():
    for p in ENGINE_SEARCH_PATHS:
        if p.is_file() and os.access(p, os.X_OK):
            return str(p)
    return None

def find_config(engine_path):
    if not engine_path:
        return None
    engine_dir = Path(engine_path).parent
    for name in ["kaiengine.conf", "kaid.conf"]:
        conf = engine_dir / name
        if conf.exists():
            return str(conf)
    xlink_conf = Path.home() / ".xlink/kaiengine.conf"
    if xlink_conf.exists():
        return str(xlink_conf)
    return None

def load_config():
    cfg = {"engine": None, "config": None}
    if CONFIG_FILE.exists():
        parser = configparser.ConfigParser()
        parser.read(CONFIG_FILE)
        if parser.has_section("xlink-kai"):
            engine = parser.get("xlink-kai", "engine_path", fallback="")
            config = parser.get("xlink-kai", "config_path", fallback="")
            cfg["engine"] = engine or None
            cfg["config"] = config or None
    if not cfg["engine"]:
        cfg["engine"] = find_engine()
    if cfg["engine"] and not cfg["config"]:
        cfg["config"] = find_config(cfg["engine"])
    return cfg

def save_config(engine, config):
    CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)
    parser = configparser.ConfigParser()
    parser["xlink-kai"] = {"engine_path": engine or "", "config_path": config or ""}
    with open(CONFIG_FILE, "w") as f:
        parser.write(f)

def is_autostart_enabled():
    return AUTOSTART_FILE.exists()

def set_autostart(enabled):
    if enabled:
        if DESKTOP_FILE.exists():
            AUTOSTART_FILE.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(DESKTOP_FILE, AUTOSTART_FILE)
    else:
        AUTOSTART_FILE.unlink(missing_ok=True)

def choose_engine_path(current_path):
    dialog = Gtk.FileChooserDialog(
        title="Select kaiengine",
        action=Gtk.FileChooserAction.OPEN,
    )
    dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
    if current_path and Path(current_path).parent.exists():
        dialog.set_current_folder(str(Path(current_path).parent))
    response = dialog.run()
    path = dialog.get_filename() if response == Gtk.ResponseType.OK else None
    dialog.destroy()
    return path

def show_error(title, message):
    dialog = Gtk.MessageDialog(
        message_type=Gtk.MessageType.ERROR,
        buttons=Gtk.ButtonsType.OK,
        text=title,
        secondary_text=message
    )
    dialog.run()
    dialog.destroy()

def show_command_dialog(title, message, command):
    dialog = Gtk.MessageDialog(
        message_type=Gtk.MessageType.INFO,
        text=title,
        secondary_text=message
    )

    content = dialog.get_content_area()
    box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
    box.set_margin_start(12)
    box.set_margin_end(12)
    box.set_margin_bottom(8)

    entry = Gtk.Entry()
    entry.set_text(command)
    entry.set_editable(False)
    entry.set_can_focus(True)
    entry.set_hexpand(True)
    box.pack_start(entry, True, True, 0)

    copy_btn = Gtk.Button(label="Copy")
    def on_copy(_):
        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
        clipboard.set_text(command, -1)
        clipboard.store()
        copy_btn.set_label("Copied!")
        GLib.timeout_add(1500, lambda: copy_btn.set_label("Copy") or False)
    copy_btn.connect("clicked", on_copy)
    box.pack_start(copy_btn, False, False, 0)

    content.pack_start(box, False, False, 0)
    box.show_all()

    dialog.add_button("OK", Gtk.ResponseType.OK)
    dialog.run()
    dialog.destroy()

def get_indicator():
    for name in ('AyatanaAppIndicator3', 'AppIndicator3'):
        try:
            gi.require_version(name, '0.1')
            return __import__('gi.repository', fromlist=[name]).__dict__[name]
        except (ImportError, ValueError, KeyError):
            pass
    return None

def get_distro_packages():
    ids = set()
    if Path("/etc/os-release").exists():
        for line in Path("/etc/os-release").read_text().splitlines():
            if line.startswith("ID="):
                ids.add(line.split("=", 1)[1].strip('"').lower())
            elif line.startswith("ID_LIKE="):
                ids.update(line.split("=", 1)[1].strip('"').lower().split())
    packages = [
        ({"fedora", "rhel", "centos", "nobara", "bazzite", "ultramarine"},
            "sudo dnf install python3-gobject libayatana-appindicator-gtk3"),
        ({"ubuntu", "debian", "pop", "linuxmint", "elementary", "zorin"},
            "sudo apt install python3-gi gir1.2-ayatanaappindicator3-0.1"),
        ({"arch", "manjaro", "endeavouros", "garuda", "cachyos"},
            "sudo pacman -S python-gobject libayatana-appindicator"),
        ({"opensuse", "opensuse-leap", "opensuse-tumbleweed", "suse"},
            "sudo zypper install python3-gobject typelib-1_0-AyatanaAppIndicator3-0_1"),
    ]
    for distro_ids, cmd in packages:
        if ids & distro_ids:
            return cmd
    return None

def has_caps(path):
    try:
        result = subprocess.run(["getcap", path], capture_output=True, text=True)
        return "cap_net_raw" in result.stdout
    except FileNotFoundError:
        return False

def set_caps(path):
    try:
        result = subprocess.run(
            ["pkexec", "setcap", "cap_net_raw,cap_net_admin=eip", path],
            capture_output=True)
        return result.returncode == 0
    except FileNotFoundError:
        return False

def setcap_command(path):
    return f"sudo setcap cap_net_raw,cap_net_admin=eip {path}"

def prompt_caps(path):
    if has_caps(path):
        return True
    dialog = Gtk.MessageDialog(
        message_type=Gtk.MessageType.WARNING,
        buttons=Gtk.ButtonsType.NONE,
        text="Network capabilities required",
        secondary_text=(
            "kaiengine needs raw network access (cap_net_raw) to tunnel "
            "game traffic. Without this, the engine cannot function.\n\n"
            "Grant permission now? (requires password)"
        )
    )
    dialog.add_buttons("Set Manually", Gtk.ResponseType.CANCEL, "Grant", Gtk.ResponseType.YES)
    dialog.set_default_response(Gtk.ResponseType.YES)
    response = dialog.run()
    dialog.destroy()
    if response == Gtk.ResponseType.YES:
        if set_caps(path):
            return True
        show_command_dialog(
            "Failed to set capabilities",
            "Run this command in a terminal:",
            setcap_command(path))
    else:
        show_command_dialog(
            "Capabilities not set",
            "Engine will not start without network capabilities.\nRun this command in a terminal:",
            setcap_command(path))
    return False

class XLinkKai:
    def __init__(self, engine_path, config_path):
        self.engine_path = engine_path
        self.config_path = config_path
        self.engine_proc = None

    def start_engine(self):
        if not self.engine_path:
            return "Engine path not set"
        engine = Path(self.engine_path)
        if not engine.is_file():
            return f"Not found: {self.engine_path}"
        if not os.access(engine, os.X_OK):
            return f"Not executable: {self.engine_path}"
        if self.engine_proc and self.engine_proc.poll() is None:
            return True
        try:
            args = [self.engine_path]
            if self.config_path and Path(self.config_path).exists():
                args.extend(["--configfile", self.config_path])
            self.engine_proc = subprocess.Popen(args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except Exception as e:
            return str(e)

    def stop_engine(self):
        if not self.engine_proc:
            return
        self.engine_proc.terminate()
        try:
            self.engine_proc.wait(timeout=3)
        except subprocess.TimeoutExpired:
            self.engine_proc.kill()
            self.engine_proc.wait(timeout=2)
        self.engine_proc = None

    def open_ui(self):
        subprocess.Popen(["xdg-open", WEB_UI], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def main():
    cfg = load_config()
    engine_path = cfg["engine"]
    config_path = cfg["config"]

    if len(sys.argv) > 1 and sys.argv[1] in ("-h", "--help"):
        print(f"Usage: {sys.argv[0]}")
        print(f"\nConfig: {CONFIG_FILE}")
        print(f"\nEngine search paths:")
        for p in ENGINE_SEARCH_PATHS:
            print(f"  {'✓' if p.exists() else '✗'} {p}")
        sys.exit(0)

    if not check_single_instance():
        show_error("XLink Kai", "XLink Kai Tray is already running.")
        sys.exit(1)

    if not engine_path or not Path(engine_path).exists():
        if not CONFIG_FILE.exists():
            save_config(None, None)
        engine_path = None
        config_path = None

    AppIndicator = get_indicator()
    if not AppIndicator:
        remove_lock()
        is_gnome = "gnome" in os.environ.get("XDG_CURRENT_DESKTOP", "").lower()
        msg = "AppIndicator library not found.\n\n"
        if is_gnome:
            msg += "GNOME requires the AppIndicator extension:\n"
            msg += "  extensions.gnome.org/extension/615/appindicator-support/\n\n"
        distro_cmd = get_distro_packages()
        if distro_cmd:
            msg += f"Install:\n  {distro_cmd}"
        else:
            msg += "Install python3-gobject + libayatana-appindicator for your distro"
        show_error("XLink Kai Error", msg)
        sys.exit(1)

    xlink = XLinkKai(engine_path, config_path)

    menu = Gtk.Menu()
    item_open = Gtk.MenuItem(label="Open Web UI")
    item_open.connect("activate", lambda _: xlink.open_ui())
    item_open.set_sensitive(False)
    menu.append(item_open)
    menu.append(Gtk.SeparatorMenuItem())

    def start_with_caps(path):
        if not prompt_caps(path):
            item_open.set_sensitive(False)
            return False
        result = xlink.start_engine()
        if result is not True:
            show_error("XLink Kai Error", f"Failed to start engine:\n{result}")
            item_open.set_sensitive(False)
            return False
        item_open.set_sensitive(True)
        return True

    def on_change_engine(_):
        path = choose_engine_path(xlink.engine_path)
        if not path:
            return
        if not os.access(path, os.X_OK):
            show_error("XLink Kai Error", f"Selected file is not executable:\n{path}")
            return
        xlink.stop_engine()
        xlink.engine_path = path
        xlink.config_path = find_config(path)
        save_config(path, xlink.config_path)
        start_with_caps(path)

    item_engine = Gtk.MenuItem(label="Set Engine Path…")
    item_engine.connect("activate", on_change_engine)
    menu.append(item_engine)

    item_autostart = Gtk.CheckMenuItem(label="Autostart")
    item_autostart.set_active(is_autostart_enabled())
    item_autostart.connect("toggled", lambda w: set_autostart(w.get_active()))
    menu.append(item_autostart)

    menu.append(Gtk.SeparatorMenuItem())

    def quit_app(_=None):
        xlink.stop_engine()
        remove_lock()
        Gtk.main_quit()

    item_quit = Gtk.MenuItem(label="Stop & Quit")
    item_quit.connect("activate", quit_app)
    menu.append(item_quit)
    menu.show_all()

    icon_path = str(ICON_PATH) if ICON_PATH.exists() else "network-workgroup"
    indicator = AppIndicator.Indicator.new("xlink-kai", icon_path, AppIndicator.IndicatorCategory.APPLICATION_STATUS)
    indicator.set_status(AppIndicator.IndicatorStatus.ACTIVE)
    indicator.set_menu(menu)

    if xlink.engine_path:
        start_with_caps(xlink.engine_path)

    signal.signal(signal.SIGTERM, lambda *_: GLib.idle_add(quit_app))
    signal.signal(signal.SIGINT, lambda *_: GLib.idle_add(quit_app))
    Gtk.main()

if __name__ == "__main__":
    main()
